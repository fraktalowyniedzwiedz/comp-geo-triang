qwedasdsda<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>3-Colored Triangulation</title>
    <style>
.demo-section {
  background: white;
  border-radius: 12px;
  padding: 35px 30px;
  margin: 50px auto;
  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
  border: 1px solid #e1e8ed;
  max-width: 900px;
}

.demo-header {
  text-align: center;
  border-bottom: 2px solid #ecf0f1;
  margin-bottom: 25px;
  padding-bottom: 10px;
}

.demo-title {
  font-size: 1.6em;
  font-weight: 700;
  color: #2c3e50;
}

.demo-description {
  background: #f8f9fa;
  padding: 18px 22px;
  border-radius: 8px;
  margin-bottom: 25px;
  border-left: 4px solid #3498db;
  font-size: 0.95em;
  line-height: 1.5;
}

#sketch-container {
  background: #fdfefe;
  border: 1px solid #dce3e8;
  border-radius: 10px;
  padding: 20px;
  min-height: 480px;
  position: relative;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.03);
}

#sketch-ui {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

#triangulate-btn {
  background: linear-gradient(135deg, #3498db, #2980b9);
  color: #fff;
  border: none;
  padding: 10px 22px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  transition: all 0.3s ease;
}
#triangulate-btn:hover {
  background: linear-gradient(135deg, #2980b9, #2573a7);
  transform: translateY(-2px);
}
#triangulate-btn:disabled {
  background: #95a5a6;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}
#status-text {
  font-size: 0.9em;
  color: #555;
  background: #eef3f6;
  padding: 6px 12px;
  border-radius: 5px;
  border: 1px solid #dce3e8;
}

.legend-container {
  margin-top: 20px;
  background: #fafbfc;
  border: 1px solid #e1e8ed;
  border-radius: 8px;
  padding: 15px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 15px;
}

.legend-title {
  font-weight: 600;
  color: #2c3e50;
  font-size: 0.95em;
}

.legend-items {
  display: flex;
  gap: 15px;
}

.legend-item {
  display: flex;
  align-items: center;
  font-size: 0.9em;
  color: #444;
}

.color-swatch {
  display: inline-block;
  width: 14px;
  height: 14px;
  border-radius: 3px;
  margin-right: 6px;
}
.color0 { background: #e74c3c; }
.color1 { background: #27ae60; }
.color2 { background: #2980b9; }

.demo-footer {
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid #ecf0f1;
  font-size: 0.9em;
  color: #555;
  line-height: 1.5;
}
.demo-footer ul {
  margin-top: 10px;
  padding-left: 20px;
}

@media (max-width: 768px) {
  .demo-section { padding: 25px 20px; }
  .legend-container { flex-direction: column; align-items: flex-start; }
  #sketch-ui { flex-direction: column; gap: 10px; }
}

html, body {
  height: auto;
  overflow: auto;
}

body {
  display: block;
}

.content {
  display: block;
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
  overflow: visible;
}


    </style>
  </head>
  <body>
    <div class="content">
      <h1>3-Colored Triangulation</h1>

      <h2>Introduction</h2>
      <p>
        Triangulations are the backbone of computational geometry. They break down arbitrary surfaces into more simple elements, triangles, over which computations such as rendering or analysis can be performed more easily.
      </p>
      <p>
        However, triangulations differ in respect to how easily they are further handled. A particularly elegant kind are <strong>3-vertex-colorable triangulations</strong>, where each vertex can be assigned one of three colors and that no two adjacent vertices share the same color. Such triangulations allow representation by efficient data structures, most notably the <strong>GEM (Graph-Encoded Manifold)</strong> representation, which makes traversal and updates simple.
      </p>
      <p>
        The problem we are faced with:
      </p>
      <div class="highlight">
        <p><strong>Given an arbitrary map on a surface, how to find a triangulation that is 3-vertex-colorable?</strong></p>
      </div>
      <div class="demo-section">
        <div class="demo-header">
        </div>
      
        <div class="demo-description">
          <p><strong>Visualizing the 3-Colored Triangulation Algorithm</strong></p>
          <p>
            This visualization demonstrates the Bueno–Stolfi 3-color triangulation algorithm applied to a cylindrical mesh.
            Click <strong>Triangulate</strong> to see the resulting 3-colored triangulation.
          </p>
        </div>
      
        <div id="sketch-container">
          <div id="sketch-ui">
            <div class="ui-left">
              <button id="triangulate-btn">Triangulate</button>
            </div>
            <div class="ui-right">
            </div>
          </div>
          <!-- p5.js canvas attaches here -->
        </div>
      </div>
      
      <h2>Theoretical Setup</h2>
      <h3>Maps and Surfaces</h3>
      <p>
        A <strong>surface</strong> is a compact 2-dimensional manifold (possibly with border). A <strong>map</strong> <span class="math">M</span> partitions that surface into vertices <span class="math">V<sub>M</sub></span>, edges <span class="math">E<sub>M</sub></span>, and faces <span class="math">F<sub>M</sub></span>, satisfying:
      </p>
      <ul>
        <li>each edge connects two distinct vertices,</li>
        <li>each face is bounded by a simple cycle of vertices and edges,</li>
        <li>edges on the border belong to only one face, interior edges to two.</li>
      </ul>

      <p>
        A <strong>triangulation</strong> is a map whose every face is a triangle.
    </p>
    <p>
        The <strong>Euler characteristic</strong>:
    </p>
    <div class="highlight">
        <p class="math">χ<sub>M</sub> = |V<sub>M</sub>| − |E<sub>M</sub>| + |F<sub>M</sub>|</p>
    </div>
    <p>
        defines the topological type of the surface (<span class="math">χ = 2</span> for a sphere, <span class="math">1</span> for a disk, <span class="math">0</span> for a torus, etc.).
    </p>

    <h2>The Algorithm</h2>
    <h3>Overview</h3>
    <p>
        The algorithm gets as input a map <span class="math">M</span> and outputs a 3-color triangulation <span class="math">T</span> of that <span class="math">M</span>.
    </p>
    <p>
        The process operates incrementally, face by face. Th invariant is that the  processed part <span class="math">T′</span> is a valid 3-colored sub-triangulation, while the remainder <span class="math">M′</span> is the unprocessed portion of the map.
    </p>
    <p>
        The two meet along a <strong>front</strong>, the set of edges and vertices shared by both.
    </p>
    <p>
        At each step, the algorithm selects a face <span class="math">m</span> adjacent to the front whose removal does not disconnect the  surface, colors its vertices, subdivides it into triangles, merges them into <span class="math">T′</span>, and updates the front.
    </p>

    <h3>The Triangulate Procedure</h3>
    <div class="algorithm">
        <ol>
            <li>Initialize <span class="math">M′ ← M</span>, <span class="math">T′ ← ∅</span>.</li>
            <li>Pick any face <span class="math">m</span> and process it.</li>
            <li>While the remaining dual graph <span class="math">M′*</span> has ≥2 vertices:
                <ul>
                    <li>choose a face <span class="math">m</span> touching the front, whose removal keeps <span class="math">M′*</span> connected,</li>
                    <li>process it.</li>
                </ul>
            </li>
            <li>Process the last remaining face, if any.</li>
            <li>Output <span class="math">T = T′</span>.</li>
        </ol>
    </div>
    <p>
        Each <strong>Process(m, T′, M′)</strong> call:
    </p>
    <ol>
        <li><strong>Colorize(m)</strong> — assign vertex colors ensuring local 3-coloring consistency.</li>
        <li>Remove <span class="math">m</span> from <span class="math">M′</span>.</li>
        <li><strong>Split(m)</strong> — subdivide <span class="math">m</span> into colored triangles.</li>
        <li>Merge new triangles into <span class="math">T′</span>.</li>
    </ol>

    <h3>Colorize</h3>
    <p>
        The Colorize step ensures that the border of <span class="math">m</span> has a valid 3-color pattern before splitting.
    </p>
    <ul>
        <li>If two front vertices of the same color are connected by an edge, divide it into two and assign the new midpoint a third color.</li>
        <li>If a color is missing from the face's boundary, assign it to an uncolored vertex.</li>
        <li>Assign the other vertices appropriate colors.</li>
    </ul>
    <p>
        After this, adjacent vertices along the border of <span class="math">m</span> all have distinct colors.
    </p>

    <h3>Split</h3>
    <p>
        Once the border of <span class="math">m</span> is properly colored, it can be subdivided.
    </p>
    <ul>
        <li>If a color is missing on <span class="math">m</span>'s border, insert a new vertex inside <span class="math">m</span> of this color, and connect it to all boundary vertices.</li>
        <li>Otherwise, while all three colors appear at least twice, find a vertex with neighbors of the two other colors and connect those neighbors—forming a triangle to reduce <span class="math">m</span>'s polygonal size.</li>
        <li>When exactly one vertex of some color remains, connect it to all nonadjacent vertices to complete triangulation.</li>
    </ul>

    <h3>Selecting Faces</h3>
    <p>
        To maintain connectivity and efficiency, the algorithm uses the extended dual graph <span class="math">M′*</span>, where:
    </p>
    <ul>
        <li>vertices correspond to faces of <span class="math">M′</span>,</li>
        <li>edges correspond to shared edges between faces,</li>
        <li>vertex <span class="math">m<sub>∅</sub></span> represents the external border.</li>
    </ul>
    <p>
        At every step the algorithm picks a face <span class="math">m</span> that keeps <span class="math">M′*</span> connected after its removal. This guarantees that <span class="math">T′</span> remains a single connected region.
    </p>
    <p>
        A preformance-focused implementation would use a priority queue of front-adjacent faces, preferring faces with simple front structures (connected front components).
    </p>

    <h3>Correctness</h3>
    <p>
        The algorithm preserves these invariants:
    </p>
    <ul>
        <li><span class="math">T′</span> and <span class="math">M′</span> together always cover the original surface <span class="math">S<sub>M</sub></span>.</li>
        <li>Their intersection (the front) consists only of shared edges and vertices.</li>
        <li><span class="math">T′</span> remains connected.</li>
        <li>Each vertex maintains a consistent 3-color assignment.</li>
    </ul>
    <p>
        When all faces are processed, <span class="math">T′</span> forms a full 3-colored subdivision of <span class="math">M</span>.
    </p>

    <h2>Time Complexity</h2>
    <p>
        The full algorithm runs in:
    </p>
    <div class="highlight">
        <p class="math">O((3 − χ)|E<sub>M</sub>|)</p>
    </div>
    <p>
        which is linear in the number of edges for any fixed surface topology.
    </p>

    <div class="conclusion">
        <h2>Conclusion</h2>
        <p>
            The 3-color triangulation algorithm provides a powerful alternative to barycentric subdivision. It guarantees a valid 3-vertex-colorable triangulation on any surface while:
        </p>
        <ul>
            <li>Reducing the number of triangles by roughly half or better,</li>
            <li>Maintaining linear time complexity,</li>
            <li>Producing output directly usable by the GEM structure.</li>
        </ul>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.min.js"></script>
    <script src="sketch.js"></script>
  </body>
</html>
